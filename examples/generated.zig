//! Auto-generated by Confu (not yet, just a mock to flesh out the APIs)
//! Any changes made to this file will be overwritten next time Confu runs
const std = @import("std");

var arena: std.heap.ArenaAllocator = undefined;
var alloc: std.mem.Allocator = undefined;
var args: []const [:0]u8 = undefined;

// TODO: add container level 'required satisfied' vars?
var help_requested: bool = false;
var current_command: ?CommandTag = null;
var last_error: ?ConfuError = null;
var last_error_message: ?[]const u8 = null;

pub const ConfuError = error{
    MissingExecutableName,
    MissingRequiredParameter,
    UnknownParameter,
    InvalidCommand,
    InvalidParameterType,
    OutOfRangeParameter,
};

pub const Options = struct {
    verbosity: u8 = 0,
};

pub const CommandTag = enum {
    cmd1,
};

pub const CommandParams = union(CommandTag) {
    cmd1: Cmd1,
};

// TODO: minimize the use of optionals?
pub const Cmd1 = struct {
    // trim: ?Cmd1ParamTrim,
    trim: ?[]const u8,
    char_map: ?std.StringHashMap([]const u8),
    output: ?union(enum) {
        stdout: bool,
        value: []const u8,
    },
    input: ?union(enum) {
        stdin: bool,
        value: [][]const u8,
    },
};

pub const Args = struct {
    const Self = @This();

    executable_name: []const u8 = undefined,
    opts: Options = Options{},
    // TODO: do we need this `command` for ergonomics?
    command: ?CommandTag = null,
    command_opts: ?CommandParams = null,

    pub fn printUsage(self: *const Self) !void {
        _ = self;
        if (help_requested) {
            const stderr_file = std.io.getStdErr().writer();
            var bw = std.io.bufferedWriter(stderr_file);
            const stderr = bw.writer();

            if (current_command != null) {
                switch (current_command.?) {
                    .cmd1 => {
                        try stderr.print("Usage: cmd1 [OPTIONS]\n", .{});
                        try stderr.print("\nOptions:\n", .{});
                        try stderr.print("  --trim <value>  Trim the input string\n", .{});
                        try stderr.print("  --char-map <value>  Replace characters in the input string\n", .{});
                        try stderr.print("  --output <value>  Output the result to stdout or a file\n", .{});
                        try stderr.print("  --input <value>  Input the string from stdin or a file\n", .{});
                    },
                }
            } else {
                try stderr.print("Usage: confu [OPTIONS] [COMMAND]\n", .{});
                try stderr.print("\nSee 'confu help <command> for more information on a specific command'\n", .{});
            }

            try bw.flush();
        }
    }

    pub fn printError(self: *const Self) !void {
        _ = self;
        if (last_error != null) {
            const stderr = std.io.getStdErr().writer();
            try stderr.print("\nError: {s}\n", .{last_error_message.?});
        }
    }

    pub fn helpRequested(self: *const Self) bool {
        _ = self;
        return help_requested;
    }

    pub fn hasError(self: *const Self) bool {
        _ = self;
        return last_error != null;
    }

    pub fn deinit(self: *Self) void {
        _ = self;
        // std.process.argsFree(alloc, args);
        arena.deinit();
    }

    pub fn getCmd1Args(self: *const Self) !*const Cmd1 {
        // if (self.command == .cmd1) {
        //     return self.command_opts.?.cmd1;
        // }
        // return Cmd1{};

        if (self.command_opts != null and self.command_opts.? == .cmd1) {
            return &(self.command_opts.?.cmd1);
        } else return ConfuError.InvalidCommand;
    }
};

pub fn parse(allocator: std.mem.Allocator) !Args {
    arena = std.heap.ArenaAllocator.init(allocator);
    alloc = arena.allocator();
    args = try std.process.argsAlloc(alloc);
    // TODO: check behavior if this, watch out for "double free" - does arena handle this or we need to handle it?
    errdefer arena.deinit();

    var result = Args{};

    // Get executable name
    if (args.len >= 1) {
        // we avoid allocations:
        // result.executable_name = std.mem.Allocator.dupe(allocator, u8, args[0]);
        result.executable_name = args[0];
    } else {
        last_error = ConfuError.MissingExecutableName;
        last_error_message = "missing executable name";
        return result;
    }

    // Parse Commands
    //   Parse Command Params
    //     in order:
    //       directly provided
    //       environment variables
    std.debug.print("args.len: {d}\n", .{args.len});
    var n: usize = 1;

    // parse options
    while (n < args.len) : (n += 1) {
        if (sw(args[n], "--")) {
            if (eq(args[n][2..], "help")) {
                // last_error = ConfuError.RequestedUsage;
                help_requested = true;
                return result;
            }
            if (eq(args[n][2..], "verbosity")) {
                result.opts.verbosity += 1;
                if (result.opts.verbosity > 3) {
                    last_error = ConfuError.OutOfRangeParameter;
                    // TODO: make 'out of range' error message customizable
                    last_error_message = "verbosity level out of range";
                    return result;
                }
            } else {
                last_error = ConfuError.UnknownParameter;
                // TODO: we could technically intorduce a new container level variable to contain a slice pointing to args[n]
                // this way we could avoid extra allocation here.
                last_error_message = try std.fmt.allocPrint(alloc, "unknown parameter: `{s}`", .{args[n]});
                return result;
            }
        } else if (sw(args[n], "-")) {
            // TODO: implement
            unreachable;
        } else {
            // encountered a non-option argument,
            break;
        }
    }

    // n += 1;
    std.debug.print("n after parsing options: {d}\n", .{n});

    // no command provided after options
    if (n > args.len - 1) {
        // TODO: allow 'top-level' command to be executed (if applicable),
        // don't just default to "help requested", let users specify the desired behavior
        // std.debug.print("no command provided after options\n", .{});
        help_requested = true;
        return result;
    }

    // determine command, immediately "process" 'help <command', otherwise set `current_command`
    if (eq(args[n], "help")) {
        help_requested = true;
        n += 1;
        if (n < args.len) {
            if (eq(args[n], "cmd1")) {
                current_command = .cmd1;
            } else {
                last_error = ConfuError.InvalidCommand;
                last_error_message = try std.fmt.allocPrint(alloc, "invalid command: `{s}`", .{args[n]});
                return result;
            }
        }
        return result;
    } else if (eq(args[n], "cmd1")) {
        current_command = .cmd1;
    } else {
        last_error = ConfuError.InvalidCommand;
        last_error_message = try std.fmt.allocPrint(alloc, "invalid command: `{s}`", .{args[n]});
        return result;
    }

    if (current_command != null) {
        n += 1;
    }

    // command without arguments
    if (n >= args.len) {
        // TODO: allow commands to be executed without arguments,
        // don't just default to "help requested", let users specify the desired behavior
        help_requested = true;
        return result;
    }

    // all commands have the '--help' and '-h' options
    // TODO: handle `-h` specially, as it could be mixed in with other short options
    if (eq(args[n], "--help") or eq(args[n], "-h")) {
        help_requested = true;
        return result;
    }

    // parse command arguments
    if (current_command) |cmd| {
        switch (cmd) {
            .cmd1 => {
                result.command = .cmd1;
                result.command_opts = CommandParams{ .cmd1 = Cmd1{
                    .trim = null,
                    .char_map = null,
                    .output = null,
                    .input = null,
                } };

                while (n < args.len) : (n += 1) {
                    std.debug.print("parsing cmd1 param {d}: {s}\n", .{ n, args[n] });
                }
            },
        }
    }

    return result;
}

fn eq(a: []const u8, b: []const u8) bool {
    return std.mem.eql(u8, a, b);
}

fn sw(a: []const u8, b: []const u8) bool {
    return std.mem.startsWith(u8, a, b);
}
