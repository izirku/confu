//! Auto-generated by Confu (not yet, just a mock to flesh out the APIs)
//! Any changes made to this file will be overwritten next time Confu runs
const std = @import("std");

var args: []const [:0]u8 = undefined;
var alloc: std.mem.Allocator = undefined;

// TODO: add container level `last_error` and `last_error_message`, 'required satisfied' vars?

pub const ConfuError = error{
    RequestedUsage,
    MissingExecutableName,
    MissingRequiredParameter,
    UnknownParameter,
    InvalidParameterType,
    OutOfRangeParameter,
};

pub const SharedParams = struct {
    verbosity: u8 = 0,
};

pub const Command = union(enum) {
    cmd1: Cmd1,
};

// TODO: minimize the use of optionals?
pub const Cmd1 = struct {
    // trim: ?Cmd1ParamTrim,
    trim: ?[]const u8,
    char_map: ?std.StringHashMap([]const u8),
    output: ?union(enum) {
        stdout: bool,
        value: []const u8,
    },
    input: ?union(enum) {
        stdin: bool,
        value: [][]const u8,
    },
};

pub const Args = struct {
    const Self = @This();

    executable_name: []const u8 = undefined,
    command: ?Command = null,
    params: SharedParams = SharedParams{},
    // TODO: make this two a container level
    @"error": ?ConfuError = null,
    error_message: []const u8 = undefined,

    pub fn printUsage(self: *const Self) !void {
        if (self.@"error") |err| {
            const stderr_file = std.io.getStdErr().writer();
            var bw = std.io.bufferedWriter(stderr_file);
            const stderr = bw.writer();

            if (err == ConfuError.RequestedUsage) {
                if (self.command) |cmd| {
                    switch (cmd) {
                        Command.cmd1 => {
                            try stderr.print("Usage: {s} cmd1 [options]\n", .{self.executable_name});
                            try stderr.print("\nOptions:\n", .{});
                            try stderr.print("  --trim <value>  Trim the input string\n", .{});
                            try stderr.print("  --char-map <value>  Replace characters in the input string\n", .{});
                            try stderr.print("  --output <value>  Output the result to stdout or a file\n", .{});
                            try stderr.print("  --input <value>  Input the string from stdin or a file\n", .{});
                        },
                    }
                } else {
                    try stderr.print("Usage: confu [command] [options]\n", .{});
                }
            } else {
                try stderr.print("\nError: {s}\n", .{self.error_message});
            }

            try bw.flush();
        }
    }

    pub fn hasError(self: *const Self) bool {
        return self.@"error" != null;
    }

    pub fn deinit(self: *Self) void {
        _ = self;
        std.process.argsFree(alloc, args);
    }

    fn parse_shared_params(self: *Self, n: *usize) ConfuError!bool {
        if (sw(args[n.*], "--")) {
            if (eq(args[n.*][2..], "help")) {
                self.@"error" = ConfuError.RequestedUsage;
                return ConfuError.RequestedUsage;
            }
            if (eq(args[n.*][2..], "verbosity")) {
                self.params.verbosity += 1;
                if (self.params.verbosity > 3) {
                    self.@"error" = ConfuError.OutOfRangeParameter;
                    // TODO: make 'out of range' error message customizable
                    self.error_message = "verbosity level out of range";
                    return ConfuError.OutOfRangeParameter;
                }
                return true;
            }
        } else if (sw(args[n.*], "-")) {
            // TODO: implement
            return false;
        }

        return false;
    }

    fn parse_cmd1_params(self: *Self, n: *usize) ConfuError!bool {
        _ = self;
        _ = n;
        return false;

        // also call `parse_shared_params` to parse any shared params from here?
        // or make an inner loop inside of a `parse` function to loop over this
        // function in conjunction with `parse_shared_params`?

        //     result.command = Command{
        //         .cmd1 = Cmd1{
        //             .trim = null,
        //             .char_map = null,
        //             .output = null,
        //             .input = null,
        //         },
        //     };

        // result.@"error" = ConfuError.UnknownParameter;
        // result.error_message = try std.fmt.allocPrint(allocator, "unknown parameter: `{s}`", .{arg});
        // return result;
    }

    // TODO: figure out how to go about matching on the command name
    /// Parse the `help [command]`
    fn parse_help_cmd(self: *Self, n: *usize) ConfuError!bool {
        _ = self;
        _ = n;
        return false;
    }
};

pub fn parse(allocator: std.mem.Allocator) !Args {
    args = try std.process.argsAlloc(allocator);
    alloc = allocator;

    var result = Args{};

    // Get executable name
    if (args.len >= 1) {
        // we avoid allocations:
        // result.executable_name = std.mem.Allocator.dupe(allocator, u8, args[0]);
        result.executable_name = args[0];
    } else {
        result.@"error" = ConfuError.MissingExecutableName;
        result.error_message = "missing executable name";
        return result;
    }

    // Parse Commands
    //   Parse Command Params
    //     in order:
    //       directly provided
    //       environment variables
    var n: usize = 1;
    while (n < args.len) : (n += 1) {

        // TODO: refactor this to allow for `exe-name help [command]`
        if (eq(args[n], "help") or eq(args[n], "-h")) {
            result.@"error" = ConfuError.RequestedUsage;
            return result;
        }

        //## Parse shared opts
        if (result.parse_shared_params(&n)) |parsed| {
            if (parsed) {
                continue;
            }
        } else |_| {
            return result;
        }

        //## Parse commands
        // TODO: use `switch` instead of `if` for more than 2 commands
        if (eq(args[n], "cmd1")) {
            n += 1;
            if (result.parse_cmd1_params(&n)) |parsed| {
                if (parsed) {
                    continue;
                }
            } else |_| {
                return result;
            }
        }
    }

    return result;
}

fn eq(a: []const u8, b: []const u8) bool {
    return std.mem.eql(u8, a, b);
}

fn sw(a: []const u8, b: []const u8) bool {
    return std.mem.startsWith(u8, a, b);
}
